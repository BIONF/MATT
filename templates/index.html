<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

        <title>Beth</title>

        <link rel="stylesheet" href="/static/bootstrap-4.3.1-dist/css/bootstrap.min.css">
        <style>
            html, body {
                height: 100%;
                width: 100%;
                background-color: lightgray;
            }
        </style>

        <script src="/static/jquery-3.4.1.min.js"></script>
        <script src="/static/popper.min.js"></script>
        <script src="/static/bootstrap-4.3.1-dist/js/bootstrap.min.js"></script>
        <script src="/static/snap.svg-min.js"></script>
        <!--<script src="/static/svg.js/svg.min.js"></script>
        <script src="/static/svg.js/svg.panzoom.min.js"></script>
        <script src="/static/jquery.svg.pan.zoom.js"></script>-->

        <script>
            $(function() {
                var maxHeight = $(window).height();
                var maxWidth = $(window).width();
                var svg;
                //var svg = Snap("100%", "100%").attr({viewBox: "0 0 " + maxWidth + " " + maxHeight});
                //var svg = Snap(maxWidth, maxHeight);
                //var input = svg.group().append(Snap.parse('<svg><foreignObject width="400" height="30"><body><form enctype="multipart/form-data"><input type="file" id="file" accept=".treefile"> <input type="button" id="import" value="Import"></form></body></foreignObject></svg>'));
                //var svgPanZoom;
                $("#import").click(function(){
                    // TODO
                    /*if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                      alert('The File APIs are not fully supported in this browser.');
                      return;
                    }

                    input = document.getElementById('fileinput');
                    if (!input) {
                      alert("Um, couldn't find the fileinput element.");
                    }
                    else if (!input.files) {
                      alert("This browser doesn't seem to support the `files` property of file inputs.");
                    }
                    else if (!input.files[0]) {
                      alert("Please select a file before clicking 'Load'");
                    } else {*/
                        var file = $("#file")[0].files[0];
                        var reader = new FileReader();

                        var senddata = new Object();
                        senddata.name = file.name;
                        senddata.date = file.lastModified;
                        senddata.size = file.size;
                        senddata.type = file.type;

                        reader.onload = function(theFileData) {
                            senddata.fileData = theFileData.target.result;
                            load("post", {file: senddata.fileData});
                        }

                        reader.readAsDataURL(file);
                        input.remove();
                    // }

                });

                function load(method, httpData) {
                    if (method == "post") {
                        $.post("load", httpData, function(data, status){
                            //alert("Data: " + data + "\nStatus: " + status);

                            if (typeof svg !== "undefined") {
                                svg.remove();
                            }

                            svg = Snap(maxWidth, maxHeight);

                            console.log(data);
                            data = JSON.parse(data);

                            extraData = data.pop();

                            maxDistance = extraData["max_distance"];
                            longestName = extraData["longest_name"];

                            var fontSize = '1.375em';
                            var strokeWidth = 4;

                            longestNameTester = svg.text(0, 0, longestName).attr({fontSize: fontSize});
                            longestNameWidth = Math.ceil(longestNameTester.getBBox().width);
                            longestNameTester.remove();

                            amount = data.length;

                            offset = 10;
                            //scaleX = 200;
                            scaleX = 500;
                            scaleY = 30;

                            svg.remove();
                            svg = Snap(((scaleX * maxDistance) + (2.5 * offset) + longestNameWidth), (scaleY * (amount + 1)));

                            //scaleX = (maxWidth - longestNameWidth - (2.5 * offset)) / maxDistance;
                            //scaleY = maxHeight / (amount + 1);

                            //var paths = [];

                            var hoveredPath;
                            var hoveredLine;
                            var clickedPath;

                            data.forEach(function(item, index, array){
                                if (item["name"] != "None") {
                                    // TODO draw all texts at the right
                                    // with path stroke dasharray
                                    svg.text(item["total_distance"] * scaleX + (1.5 * offset), (index + 1) * scaleY, item["name"]).attr({dominantBaseline: 'middle', fontSize: fontSize, 'data-id': item["id"]});
                                } else {
                                    l_child = array.findIndex((elem) => elem.id == item["l_child"]);
                                    r_child = array.findIndex((elem) => elem.id == item["r_child"]);

                                    // TODO CHECK THIS AGAIN, Example6 seems to be faulty
                                    mX = (item["total_distance"] * scaleX) + offset;
                                    mYLeft = (index + 1) * scaleY - strokeWidth;
                                    mYRight = (index + 1) * scaleY + strokeWidth;

                                    if(item["id"] == 0) {
                                        mYLeft += strokeWidth / 2;
                                        mYRight -= strokeWidth / 2;
                                    }

                                    vLeft = (l_child + 1) * scaleY;
                                    vRight = (r_child + 1) * scaleY;
                                    hLeft = array[l_child]["total_distance"] * scaleX + offset;
                                    hRight = array[r_child]["total_distance"] * scaleX + offset;

                                    //TODO
                                    left = svg.path("M" + mX + "," + mYLeft + "V" + vLeft + "H" + hLeft).attr("data-id", array[l_child]["id"]);
                                    right = svg.path("M" + mX + "," + mYRight + "V" + vRight + "H" + hRight).attr("data-id", array[r_child]["id"]);

                                    if (("l_child" in array[l_child]) && ("r_child" in array[l_child])) {
                                        left.attr({"data-l_child": array[l_child]["l_child"], "data-r_child": array[l_child]["r_child"]});
                                    }
                                    if (("l_child" in array[r_child]) && ("r_child" in array[r_child])) {
                                        right.attr({"data-l_child": array[r_child]["l_child"], "data-r_child": array[r_child]["r_child"]});
                                    }

                                    //paths = paths.concat([left, right]);
                                    paths = [left, right];

                                    paths.forEach(function(itemPath, indexPath, arrayPath) {
                                        itemPath.attr({fill: 'none', stroke: 'black', strokeWidth: strokeWidth, strokeLinecap: 'square'});
                                        //itemPath.data({'posX': array[l_child]["total_distance"] * scale, 'posY': (l_child + 1) * offset});
                                        itemPath.mouseover(function() {
                                            itemPath.attr({stroke: 'dodgerblue', strokeWidth: strokeWidth * 2});
                                            if (typeof hoveredPath === "undefined" || (typeof hoveredPath === "object" && !hoveredPath)) {
                                                hoveredPath = itemPath.use().attr({pointerEvents: 'none'});
                                            }
                                        });
                                        itemPath.mouseout(function() {
                                            itemPath.attr({stroke: 'black', strokeWidth: strokeWidth});
                                            hoveredPath.remove();
                                            hoveredPath = null;
                                        });
                                        itemPath.click(function() {
                                            if (typeof clickedPath === "undefined" || (typeof clickedPath === "object" && !clickedPath)) {
                                                hoveredPath.remove();
                                                clickedPath = itemPath;
                                                itemPath.attr({strokeOpacity: 0.25});
                                                childrenIds = [itemPath.attr("data-l_child"), itemPath.attr("data-r_child")];
                                                while ((typeof childrenIds !== "undefined") && (childrenIds.length > 0)) {
                                                    childId = childrenIds.shift();
                                                    childPath = svg.select("path[data-id='" + childId + "']");
                                                    if (childPath) {
                                                        childPath.attr({strokeOpacity: 0.25, pointerEvents: 'none'});
                                                        if (childPath.attr("data-l_child") && childPath.attr("data-r_child")) {
                                                            childrenIds.push(childPath.attr("data-l_child"), childPath.attr("data-r_child"));
                                                        }
                                                    }
                                                    childText = svg.select("text[data-id='" + childId + "']");
                                                    if (childText) {
                                                        childText.attr({opacity: 0.25, pointerEvents: 'none'});
                                                    }
                                                }
                                            } else if (clickedPath == itemPath) {
                                                hoveredPath.remove();
                                                clickedPath = null;
                                                itemPath.attr({strokeOpacity: ''});
                                                childrenIds = [itemPath.attr("data-l_child"), itemPath.attr("data-r_child")];
                                                while ((typeof childrenIds !== "undefined") && (childrenIds.length > 0)) {
                                                    childId = childrenIds.shift();
                                                    childPath = svg.select("path[data-id='" + childId + "']");
                                                    if (childPath) {
                                                        childPath.attr({strokeOpacity: '', pointerEvents: ''});
                                                        if (childPath.attr("data-l_child") && childPath.attr("data-r_child")) {
                                                            childrenIds.push(childPath.attr("data-l_child"), childPath.attr("data-r_child"));
                                                        }
                                                    }
                                                    childText = svg.select("text[data-id='" + childId + "']");
                                                    if (childText) {
                                                        childText.attr({opacity: '', pointerEvents: ''});
                                                    }
                                                }
                                            } else {
                                                load("get", {'from': clickedPath.attr("data-id"), 'to': itemPath.attr("data-id")});
                                                console.log({'from': clickedPath.attr("data-id"), 'to': itemPath.attr("data-id")});
                                            }
                                        });

                                        /*itemPath.drag(function(dx, dy, x, y, event) {
                                            // TODO does not have to be set every frame
                                            pos = itemPath.attr("d");
                                            posX = pos.split("H")[1];
                                            posY = pos.split("H")[0].split("V")[1];
                                            hoveredLine.remove();
                                            hoveredLine = svg.line(posX, posY, x, y);
                                            hoveredLine.attr({stroke: 'black', strokeWidth: strokeWidth});
                                            console.log("move");
                                        }, function(x, y, event) {
                                            pos = itemPath.attr("d");
                                            posX = pos.split("H")[1];
                                            posY = pos.split("H")[0].split("V")[1];
                                            hoveredPath.remove();
                                            itemPath.remove();
                                            hoveredLine = svg.line(posX, posY, x, y);
                                            hoveredLine.attr({stroke: 'black', strokeWidth: strokeWidth});
                                            console.log("start");
                                        }, function(event) {
                                            console.log("stop");
                                        });*/

                                    });
                                    /*both = svg.line(here, (l_child + 1) * offset, here, (r_child + 1) * offset);
                                    left = svg.line(here, (l_child + 1) * offset, array[l_child]["total_distance"] * scale, (l_child + 1) * offset);
                                    right = svg.line(here, (r_child + 1) * offset, array[r_child]["total_distance"] * scale, (r_child + 1) * offset);

                                    lines = [both, left, right];

                                    lines.forEach(function(itemLine) {
                                        itemLine.attr({
                                            stroke: 'black',
                                            strokeWidth: 2,
                                            strokeLinecap: 'square'
                                        });
                                        itemLine.hover(function() {
                                            itemLine.attr({
                                                stroke: 'darkgray',
                                                strokeWidth: 4
                                            });
                                            hoveredLine = this.use();
                                        }, function() {
                                            itemLine.attr({
                                                stroke: 'black',
                                                strokeWidth: 2
                                            });
                                            hoveredLine.remove();
                                        });
                                        itemLine.click(function() {
                                            itemLine.attr({
                                                stroke: 'black',
                                                strokeWidth: 0
                                            });
                                            hoveredLine.remove();
                                        });
                                    });*/

                                    //left.append(Snap.parse('<title>' + array[l_child]["total_distance"] - item["total_distance"] + '</title>'));
                                    //right.append(Snap.parse('<title>' + array[r_child]["total_distance"] - item["total_distance"] + '</title>'));
                                }
                            });
                            /*var options = {
                                limits: {
                                    x: 0,
                                    y: 0,
                                    x2: 1000,
                                    y2: 1000
                                },
                                maxZoom: 10
                            };
                            svgPanZoom = $("svg").svgPanZoom(options);
                            // TODO resolve necessity for this
                            svgPanZoom.zoomIn();
                            svgPanZoom.zoomIn();
                            svgPanZoom.panLeft(maxWidth);
                            svgPanZoom.panUp(maxHeight);
                            // TODO
                            */
                            // TODO Do an own panzoom
                        });
                    } else {
                        $.get("load", httpData, function(data, status){
                            //TODO
                        });
                    }
                }
            });

            /*$(window).resize(function() {
                svg.size($(window).width(), $(window).height());
            });*/

        </script>
    </head>
    <body><form enctype="multipart/form-data"><input type="file" id="file" accept=".treefile"> <input type="button" id="import" value="Import"></form></body>
</html>
